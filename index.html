<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three.js 太空漂浮立方体</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000000;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "San Francisco", "Helvetica Neue", Arial, sans-serif;
            cursor: grab;
        }
        body.dragging {
            cursor: grabbing;
        }
        canvas {
            display: block;
        }
        #info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 14px;
            pointer-events: none;
            padding: 10px 20px;
            animation: pulse 6s infinite;
            background: transparent !important;
        }
        
        @keyframes pulse {
            0% {
                color: #000000;
            }
            50% {
                color: #ffffff;
            }
            100% {
                color: #000000;
            }
        }
        
        /* 顶部导航栏样式 */
        .navbar {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 60px;
            background: transparent;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 20px;
            box-sizing: border-box;
            z-index: 100;
            pointer-events: auto;
        }
        
        .nav-left {
            display: flex;
            align-items: center;
        }
        
        .nav-item {
            color: white;
            font-size: 16px;
            margin-right: 30px;
            text-decoration: none;
            transition: all 0.3s ease;
            padding: 8px 8px;
            border-radius: 4px;
        }
        
        .nav-item:hover {
            color: #ffffff;
            text-shadow: 0 0 8px rgba(255, 255, 255, 0.8);
            transform: scale(1.05);
        }
        
        .nav-item:active {
            transform: scale(0.95);
        }
        
        .search-container {
            display: flex;
            align-items: center;
        }
        
        .search-btn {
            width: 160px;
            height: 20px;
            border: 1px solid white;
            background: transparent;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 0 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 10px; /* 四个角都倒圆角 */
            position: relative;
        }
        
        .search-btn:hover {
            border-color: #ffffff;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            transform: scale(1.05);
        }
        
        .search-btn:active {
            transform: scale(0.95);
        }
        
        /* SVG放大镜图标 */
        .search-icon {
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .search-icon svg {
            width: 16px;
            height: 16px;
        }
        
        .search-icon circle,
        .search-icon line {
            stroke: white;
            stroke-width: 1;
            fill: none;
            transition: stroke 0.3s ease;
        }
        
        .search-btn:hover .search-icon circle,
        .search-btn:hover .search-icon line {
            stroke: #ffffff;
            filter: drop-shadow(0 0 4px rgba(255, 255, 255, 0.8));
        }
        
        /* 隐藏音频元素 */
        #bgm {
            display: none;
        }
        
        /* 音乐控制按钮 */
        .music-control {
            position: absolute;
            bottom: 20px;
            left: 20px;
            font-size: 20px;
            cursor: pointer;
            z-index: 100;
            transition: all 0.3s ease;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .music-control:hover {
            transform: scale(1.1);
        }
        
        .music-icon {
            color: white;
            transition: all 0.3s ease;
        }
        
        .music-control.muted .fa-volume-high {
            display: none;
        }
        
        .music-control:not(.muted) .fa-volume-xmark {
            display: none;
        }
        
        .music-control.muted .fa-volume-xmark {
            color: #888888;
        }
        
        /* 骰子按钮 */
        .dice-control {
            position: absolute;
            bottom: 20px;
            right: 20px;
            font-size: 20px;
            cursor: pointer;
            z-index: 100;
            transition: all 0.3s ease;
            width: 24px;
            height: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
        }
        
        .dice-control:hover {
            transform: scale(1.1);
        }
        
        .dice-control.changing {
            animation: rotate 2s linear;
        }
        
        @keyframes rotate {
            from {
                transform: rotate(0deg) scale(1.1);
            }
            to {
                transform: rotate(360deg) scale(1.1);
            }
        }
    </style>
</head>
<body>
    <!-- 顶部导航栏 -->
    <nav class="navbar">
        <div class="nav-left">
            <a href="#" class="nav-item">Discover</a>
            <a href="#" class="nav-item">Space</a>
            <a href="#" class="nav-item">Starships</a>
            <a href="#" class="nav-item">Store</a>
        </div>
        <div class="search-container">
            <button class="search-btn">
                <div class="search-icon">
                    <svg viewBox="0 0 16 16">
                        <circle cx="7" cy="7" r="5"></circle>
                        <line x1="11" y1="11" x2="15" y2="15" stroke-linecap="round"></line>
                    </svg>
                </div>
            </button>
        </div>
    </nav>
    
    <!-- 背景音乐 -->
    <audio id="bgm" loop preload="auto">
        <source src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-4.mp3" type="audio/mpeg">
        您的浏览器不支持音频播放。
    </audio>
    
    <!-- 音乐控制按钮 -->
    <div class="music-control" id="musicControl">
        <i class="fa-solid fa-volume-high music-icon"></i>
        <i class="fa-solid fa-volume-xmark music-icon"></i>
    </div>
    
    <!-- 骰子按钮 -->
    <div class="dice-control" id="diceControl">
        <i class="fa-solid fa-dice-d20"></i>
    </div>
    
    <div id="info">按住鼠标左键并拖拽来旋转立方体</div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // 创建场景
        const scene = new THREE.Scene();
        
        // 创建透视相机
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
        camera.position.z = 5;
        
        // 创建渲染器
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000);
        document.body.appendChild(renderer.domElement);
        
        // 创建立方体几何体
        const geometry = new THREE.BoxGeometry(2, 2, 2);
        
        // 颜色生成函数
        function getRandomColor() {
            const colors = [
                0xff6b6b, // 红珊瑚
                0x4ecdc4, // 薄荷绿
                0x45b7d1, // 天蓝
                0x96ceb4, // 薄荷绿
                0xfeca57, // 金黄
                0xff9ff3, // 粉红
                0x54a0ff, // 蓝色
                0x5f27cd, // 紫色
                0x00d2d3, // 青色
                0xff9f43, // 橙色
                0x10ac84, // 绿色
                0xee5a24, // 橙红
                0xa8e6cf, // 淡绿
                0xdcedc1, // 淡黄绿
                0xffd3b6, // 淡橙
                0xffaaa5  // 淡粉
            ];
            return colors[Math.floor(Math.random() * colors.length)];
        }
        
        // 计算两个颜色之间的差异（简单RGB距离）
        function colorDifference(color1, color2) {
            const r1 = (color1 >> 16) & 0xff;
            const g1 = (color1 >> 8) & 0xff;
            const b1 = color1 & 0xff;
            
            const r2 = (color2 >> 16) & 0xff;
            const g2 = (color2 >> 8) & 0xff;
            const b2 = color2 & 0xff;
            
            // 计算RGB空间中的欧几里得距离
            return Math.sqrt(Math.pow(r1 - r2, 2) + Math.pow(g1 - g2, 2) + Math.pow(b1 - b2, 2));
        }
        
        // 获取两种差异较大的随机颜色
        function getContrastingColors() {
            let color1, color2;
            let attempts = 0;
            const maxAttempts = 50;
            const minDifference = 100; // 最小颜色差异阈值
            
            do {
                color1 = getRandomColor();
                color2 = getRandomColor();
                attempts++;
            } while (color1 === color2 && attempts < maxAttempts);
            
            // 如果随机选择的颜色差异太小，继续寻找差异较大的颜色对
            attempts = 0;
            while (colorDifference(color1, color2) < minDifference && attempts < maxAttempts) {
                color2 = getRandomColor();
                attempts++;
            }
            
            return {
                color1: new THREE.Color(color1),
                color2: new THREE.Color(color2)
            };
        }
        
        // 获取初始两种差异较大的随机颜色
        const initialColors = getContrastingColors();
        let currentColor1 = initialColors.color1;
        let currentColor2 = initialColors.color2;
        
        // 创建自定义着色器材质实现渐变效果
        const material = new THREE.ShaderMaterial({
            uniforms: {
                color1: { value: currentColor1 },
                color2: { value: currentColor2 },
                bboxMin: { value: new THREE.Vector3(-1, -1, -1) },
                bboxMax: { value: new THREE.Vector3(1, 1, 1) }
            },
            vertexShader: `
                uniform vec3 bboxMin;
                uniform vec3 bboxMax;
                
                varying vec2 vUv;
                varying vec3 vPosition;
                
                void main() {
                    vUv = uv;
                    vPosition = position;
                    
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                uniform vec3 color1;
                uniform vec3 color2;
                uniform vec3 bboxMin;
                uniform vec3 bboxMax;
                
                varying vec3 vPosition;
                
                void main() {
                    // 计算渐变因子
                    vec3 normalizedPos = (vPosition - bboxMin) / (bboxMax - bboxMin);
                    float gradient = (normalizedPos.x + normalizedPos.y + normalizedPos.z) / 3.0;
                    
                    // 混合两种颜色
                    vec3 finalColor = mix(color1, color2, gradient);
                    
                    // 设置透明度
                    gl_FragColor = vec4(finalColor, 0.7);
                }
            `,
            transparent: true,
            side: THREE.DoubleSide
        });
        
        // 创建网格对象
        const cube = new THREE.Mesh(geometry, material);
        scene.add(cube);
        
        // 添加点光源
        const pointLight = new THREE.PointLight(0xffffff, 1, 100);
        pointLight.position.set(5, 5, 5);
        scene.add(pointLight);
        
        // 添加环境光以提供基础照明
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);
        
        // 添加辅助光源增强立体感
        const backLight = new THREE.PointLight(0xffffff, 0.5, 100);
        backLight.position.set(-5, -5, -5);
        scene.add(backLight);
        
        // 创建星空背景
        function createStarField() {
            const starCount = 5000;
            const starGeometry = new THREE.BufferGeometry();
            const starPositions = new Float32Array(starCount * 3);
            const starSizes = new Float32Array(starCount);
            
            for (let i = 0; i < starCount; i++) {
                // 在一个大的立方体空间内随机分布星星
                const range = 1000;
                starPositions[i * 3] = (Math.random() - 0.5) * range;
                starPositions[i * 3 + 1] = (Math.random() - 0.5) * range;
                starPositions[i * 3 + 2] = (Math.random() - 0.5) * range;
                
                // 随机大小（0.5到3）
                starSizes[i] = Math.random() * 2.5 + 0.5;
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
            starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
            
            // 使用自定义着色器材质创建圆形星星
            const starMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    attribute float size;
                    uniform float time;
                    varying float vBrightness;
                    
                    void main() {
                        // 计算闪烁亮度 - 每颗星星有不同的闪烁频率
                        float speed = 0.5 + mod(position.x + position.y + position.z, 2.0);
                        vBrightness = 0.5 + 0.5 * sin(time * speed + position.x * 0.01);
                        vBrightness = 0.4 + 0.6 * vBrightness; // 确保最小亮度
                        
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = size * (300.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying float vBrightness;
                    
                    void main() {
                        // 创建圆形星星
                        vec2 coord = gl_PointCoord - vec2(0.5);
                        float distance = length(coord);
                        if (distance > 0.5) discard;
                        
                        // 渐变效果
                        float alpha = 1.0 - distance * 2.0;
                        alpha = alpha * vBrightness;
                        
                        // 白色星星，根据大小调整亮度
                        gl_FragColor = vec4(1.0, 1.0, 1.0, alpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                depthTest: false
            });
            
            const starField = new THREE.Points(starGeometry, starMaterial);
            return starField;
        }
        
        // 添加星空到场景
        const starField = createStarField();
        scene.add(starField);
        
        // 太空漂浮控制变量
        const naturalRotation = new THREE.Vector3(0.001, 0.002, 0.0005);
        
        // 鼠标控制变量
        let isDragging = false;
        let previousMousePosition = {
            x: 0,
            y: 0
        };
        
        // 旋转速度向量 - 用于惯性物理效果
        const rotationVelocity = new THREE.Vector3(0, 0, 0);
        const tempRotation = new THREE.Vector3(0, 0, 0); // 临时存储拖拽时的旋转速度
        
        const damping = 0.98; // 阻尼系数
        const sensitivity = 0.005; // 鼠标灵敏度
        const transitionSpeed = 0.02; // 过渡速度
        
        // 音乐控制
        const bgm = document.getElementById('bgm');
        const musicControl = document.getElementById('musicControl');
        let isMuted = false;
        
        // 播放音乐
        function playMusic() {
            bgm.play().catch(error => {
                console.log('音频播放需要用户交互');
            });
        }
        
        // 暂停音乐
        function pauseMusic() {
            bgm.pause();
        }
        
        // 切换音乐状态
        function toggleMusic() {
            isMuted = !isMuted;
            if (isMuted) {
                pauseMusic();
                musicControl.classList.add('muted');
            } else {
                playMusic();
                musicControl.classList.remove('muted');
            }
        }
        
        // 点击音乐控制按钮
        musicControl.addEventListener('click', function(e) {
            e.stopPropagation();
            toggleMusic();
        });
        
        // 颜色变化控制
        const diceControl = document.getElementById('diceControl');
        let isChanging = false;
        let changeStartTime = 0;
        const changeDuration = 2000; // 2秒
        
        // 起始颜色和目标颜色
        let startColor1 = currentColor1.clone();
        let startColor2 = currentColor2.clone();
        let targetColor1 = currentColor1.clone();
        let targetColor2 = currentColor2.clone();
        
        // 获取两种差异较大的随机颜色
        function getContrastingColors() {
            let color1, color2;
            let attempts = 0;
            const maxAttempts = 50;
            const minDifference = 100; // 最小颜色差异阈值
            
            do {
                color1 = getRandomColor();
                color2 = getRandomColor();
                attempts++;
            } while (color1 === color2 && attempts < maxAttempts);
            
            // 如果随机选择的颜色差异太小，继续寻找差异较大的颜色对
            attempts = 0;
            while (colorDifference(color1, color2) < minDifference && attempts < maxAttempts) {
                color2 = getRandomColor();
                attempts++;
            }
            
            return {
                color1: new THREE.Color(color1),
                color2: new THREE.Color(color2)
            };
        }
        
        // 计算两个颜色之间的差异（简单RGB距离）
        function colorDifference(color1, color2) {
            const r1 = (color1 >> 16) & 0xff;
            const g1 = (color1 >> 8) & 0xff;
            const b1 = color1 & 0xff;
            
            const r2 = (color2 >> 16) & 0xff;
            const g2 = (color2 >> 8) & 0xff;
            const b2 = color2 & 0xff;
            
            // 计算RGB空间中的欧几里得距离
            return Math.sqrt(Math.pow(r1 - r2, 2) + Math.pow(g1 - g2, 2) + Math.pow(b1 - b2, 2));
        }
        
        // 生成新颜色（确保差异性）
        function generateNewColors() {
            let newColors;
            let attempts = 0;
            const maxAttempts = 50;
            
            // 确保新颜色与当前颜色有足够的差异
            do {
                newColors = getContrastingColors();
                attempts++;
            } while (
                (colorDifference(newColors.color1.getHex(), currentColor1.getHex()) < 100 ||
                colorDifference(newColors.color2.getHex(), currentColor2.getHex()) < 100) &&
                attempts < maxAttempts
            );
            
            return newColors;
        }
        
        // 开始颜色变化
        function startColorChange() {
            if (isChanging) return;
            
            isChanging = true;
            changeStartTime = Date.now();
            diceControl.classList.add('changing');
            
            // 保存当前颜色作为起始颜色
            startColor1 = currentColor1.clone();
            startColor2 = currentColor2.clone();
            
            // 生成新颜色作为目标颜色
            const newColors = generateNewColors();
            targetColor1 = newColors.color1;
            targetColor2 = newColors.color2;
        }
        
        // 更新颜色变化
        function updateColorChange() {
            if (!isChanging) return;
            
            const elapsed = Date.now() - changeStartTime;
            const progress = Math.min(elapsed / changeDuration, 1.0);
            
            // 使用缓动函数使过渡更平滑
            const easeProgress = 1 - Math.pow(1 - progress, 3);
            
            // 插值颜色
            const interpolatedColor1 = startColor1.clone().lerp(targetColor1, easeProgress);
            const interpolatedColor2 = startColor2.clone().lerp(targetColor2, easeProgress);
            
            // 更新材质
            material.uniforms.color1.value = interpolatedColor1;
            material.uniforms.color2.value = interpolatedColor2;
            
            // 更新当前颜色
            currentColor1 = interpolatedColor1;
            currentColor2 = interpolatedColor2;
            
            if (progress >= 1.0) {
                isChanging = false;
                diceControl.classList.remove('changing');
            }
        }
        
        // 点击骰子按钮
        diceControl.addEventListener('click', function(e) {
            e.stopPropagation();
            startColorChange();
        });
        
        // 窗口大小调整处理
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // 鼠标按下事件
        renderer.domElement.addEventListener('mousedown', (event) => {
            isDragging = true;
            document.body.classList.add('dragging');
            previousMousePosition = {
                x: event.clientX,
                y: event.clientY
            };
        });
        
        // 鼠标移动事件
        window.addEventListener('mousemove', (event) => {
            if (isDragging) {
                const deltaX = event.clientX - previousMousePosition.x;
                const deltaY = event.clientY - previousMousePosition.y;
                
                // 存储当前旋转速度用于惯性
                tempRotation.y = deltaX * sensitivity;
                tempRotation.x = deltaY * sensitivity;
                
                // 直接应用旋转
                cube.rotation.x += tempRotation.x;
                cube.rotation.y += tempRotation.y;
                
                previousMousePosition = {
                    x: event.clientX,
                    y: event.clientY
                };
            }
        });
        
        // 鼠标释放事件
        window.addEventListener('mouseup', () => {
            if (isDragging) {
                isDragging = false;
                document.body.classList.remove('dragging');
                // 将临时旋转速度应用到实际旋转速度，实现惯性效果
                rotationVelocity.copy(tempRotation);
            }
        });
        
        // 防止拖拽时选择文本
        window.addEventListener('selectstart', (event) => {
            if (isDragging) {
                event.preventDefault();
            }
        });
        
        // 动画渲染循环
        function animate() {
            requestAnimationFrame(animate);
            
            // 更新颜色变化
            updateColorChange();
            
            // 更新星星闪烁效果
            const time = performance.now() * 0.001;
            starField.material.uniforms.time.value = time;
            
            if (isDragging) {
                // 拖拽时已经在mousemove中处理了旋转
            } else {
                // 非拖拽时处理惯性物理效果
                // 应用惯性旋转
                cube.rotation.x += rotationVelocity.x;
                cube.rotation.y += rotationVelocity.y;
                cube.rotation.z += rotationVelocity.z;
                
                // 应用阻尼减速
                rotationVelocity.multiplyScalar(damping);
                
                // 平滑过渡到自然漂浮
                // 逐渐将当前速度向自然漂浮速度过渡
                rotationVelocity.x += (naturalRotation.x - rotationVelocity.x) * transitionSpeed;
                rotationVelocity.y += (naturalRotation.y - rotationVelocity.y) * transitionSpeed;
                rotationVelocity.z += (naturalRotation.z - rotationVelocity.z) * transitionSpeed;
            }
            
            renderer.render(scene, camera);
        }
        
        // 启动渲染循环
        animate();
        
        // 页面加载完成后尝试播放音乐
        window.addEventListener('load', function() {
            // 页面加载后立即尝试播放
            playMusic();
        });
        
        // 用户首次交互后播放音乐（备用方案）
        document.addEventListener('click', function() {
            if (!isMuted) {
                playMusic();
            }
        }, { once: true });
        
        // 页面可见时尝试播放音乐
        document.addEventListener('visibilitychange', function() {
            if (!document.hidden && !isMuted) {
                playMusic();
            }
        });
    </script>
</body>
</html>
